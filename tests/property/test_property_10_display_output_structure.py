"""Property-based tests for display output structure

Feature: realtime-sentiment-analysis, Property 10: Display output structure
Validates: Requirements 7.1, 7.2
"""

import pytest
import time
from hypothesis import given, strategies as st, settings

from src.ui.display import SentimentDisplay
from src.models.results import SentimentScore


# Custom strategies for generating test data
@st.composite
def emotion_breakdown_strategy(draw):
    """Generate random emotion breakdown dictionaries.
    
    Emotion breakdowns are dictionaries mapping emotion names to scores in [0, 1].
    The scores should sum to approximately 1.0 (normalized probability distribution).
    """
    emotions = ['happy', 'sad', 'angry', 'neutral', 'fearful', 'surprised', 'disgust']
    
    # Generate random scores
    num_emotions = draw(st.integers(min_value=1, max_value=len(emotions)))
    selected_emotions = draw(st.lists(
        st.sampled_from(emotions),
        min_size=num_emotions,
        max_size=num_emotions,
        unique=True
    ))
    
    # Generate random scores and normalize to sum to 1.0
    raw_scores = [draw(st.floats(min_value=0.0, max_value=1.0)) for _ in selected_emotions]
    total = sum(raw_scores)
    
    if total > 0:
        normalized_scores = {emotion: score / total for emotion, score in zip(selected_emotions, raw_scores)}
    else:
        # Fallback to equal distribution
        normalized_scores = {emotion: 1.0 / len(selected_emotions) for emotion in selected_emotions}
    
    return normalized_scores


@st.composite
def modality_contributions_strategy(draw):
    """Generate random modality contribution dictionaries.
    
    Modality contributions are dictionaries mapping modality names to weight values in [0, 1].
    The weights should sum to approximately 1.0 (normalized weights).
    """
    modalities = ['acoustic', 'visual', 'linguistic']
    
    # Decide which modalities are present (at least one)
    num_modalities = draw(st.integers(min_value=1, max_value=3))
    selected_modalities = draw(st.lists(
        st.sampled_from(modalities),
        min_size=num_modalities,
        max_size=num_modalities,
        unique=True
    ))
    
    # Generate random weights and normalize to sum to 1.0
    raw_weights = [draw(st.floats(min_value=0.0, max_value=1.0)) for _ in selected_modalities]
    total = sum(raw_weights)
    
    if total > 0:
        normalized_weights = {modality: weight / total for modality, weight in zip(selected_modalities, raw_weights)}
    else:
        # Fallback to equal distribution
        normalized_weights = {modality: 1.0 / len(selected_modalities) for modality in selected_modalities}
    
    return normalized_weights


@st.composite
def sentiment_score_strategy(draw):
    """Generate random SentimentScore instances."""
    score = draw(st.floats(min_value=-1.0, max_value=1.0))
    confidence = draw(st.floats(min_value=0.0, max_value=1.0))
    modality_contributions = draw(modality_contributions_strategy())
    emotion_breakdown = draw(emotion_breakdown_strategy())
    timestamp = draw(st.floats(min_value=0.0, max_value=10000.0))
    
    return SentimentScore(
        score=score,
        confidence=confidence,
        modality_contributions=modality_contributions,
        emotion_breakdown=emotion_breakdown,
        timestamp=timestamp
    )


# Feature: realtime-sentiment-analysis, Property 10: Display output structure
@settings(max_examples=100, deadline=None)
@given(sentiment=sentiment_score_strategy())
def test_display_output_contains_required_fields(sentiment):
    """
    Property 10: Display output structure
    
    For any sentiment score generated by the Fusion Engine, the display output 
    should contain the score, timestamp, and individual modality contributions 
    (acoustic, visual, linguistic).
    
    This property verifies that:
    1. The SentimentScore data model contains all required fields
    2. The score field is present and in valid range
    3. The timestamp field is present and valid
    4. The modality_contributions field is present and properly structured
    5. This holds regardless of:
       - The sentiment score value (positive, negative, or neutral)
       - The confidence level
       - Which modalities contributed (all, some, or one)
       - The emotion breakdown
       - The timestamp value
    
    This is a critical correctness property that ensures the display interface
    receives all required information for visualization, enabling users to 
    understand both the current sentiment and the contributing factors from 
    each analysis modality.
    
    Validates:
    - Req 7.1: System displays sentiment score with timestamp
    - Req 7.2: System shows individual contributions from acoustic, visual, 
               and linguistic analysis
    """
    # Property assertions: SentimentScore must contain all required fields
    
    # 1. SentimentScore must have score attribute
    assert hasattr(sentiment, 'score'), \
        "SentimentScore must have score attribute"
    assert isinstance(sentiment.score, (int, float)), \
        f"Score must be numeric, got {type(sentiment.score)}"
    assert -1.0 <= sentiment.score <= 1.0, \
        f"Score must be in [-1.0, 1.0], got {sentiment.score}"
    
    # 2. SentimentScore must have timestamp attribute
    assert hasattr(sentiment, 'timestamp'), \
        "SentimentScore must have timestamp attribute"
    assert isinstance(sentiment.timestamp, (int, float)), \
        f"Timestamp must be numeric, got {type(sentiment.timestamp)}"
    assert sentiment.timestamp >= 0, \
        f"Timestamp must be non-negative, got {sentiment.timestamp}"
    
    # 3. SentimentScore must have confidence attribute
    assert hasattr(sentiment, 'confidence'), \
        "SentimentScore must have confidence attribute"
    assert isinstance(sentiment.confidence, (int, float)), \
        f"Confidence must be numeric, got {type(sentiment.confidence)}"
    assert 0.0 <= sentiment.confidence <= 1.0, \
        f"Confidence must be in [0.0, 1.0], got {sentiment.confidence}"
    
    # 4. SentimentScore must have modality_contributions attribute
    assert hasattr(sentiment, 'modality_contributions'), \
        "SentimentScore must have modality_contributions attribute"
    assert isinstance(sentiment.modality_contributions, dict), \
        f"modality_contributions must be a dict, got {type(sentiment.modality_contributions)}"
    
    # 5. Modality contributions must be non-empty (at least one modality)
    assert len(sentiment.modality_contributions) > 0, \
        "modality_contributions must contain at least one modality"
    
    # 6. Each modality contribution must be a valid weight [0, 1]
    for modality, weight in sentiment.modality_contributions.items():
        assert isinstance(modality, str), \
            f"Modality name must be string, got {type(modality)}"
        assert isinstance(weight, (int, float)), \
            f"Modality weight must be numeric, got {type(weight)}"
        assert 0.0 <= weight <= 1.0, \
            f"Modality weight for {modality} must be in [0, 1], got {weight}"
    
    # 7. SentimentScore must have emotion_breakdown attribute
    assert hasattr(sentiment, 'emotion_breakdown'), \
        "SentimentScore must have emotion_breakdown attribute"
    assert isinstance(sentiment.emotion_breakdown, dict), \
        f"emotion_breakdown must be a dict, got {type(sentiment.emotion_breakdown)}"
    
    # 8. Display can accept the SentimentScore without error
    display = SentimentDisplay()
    try:
        display.update_score(sentiment)
    except Exception as e:
        assert False, f"Display must accept valid SentimentScore without error, got: {e}"


# Feature: realtime-sentiment-analysis, Property 10: Display output structure
@settings(max_examples=100, deadline=None)
@given(
    sentiments=st.lists(
        sentiment_score_strategy(),
        min_size=1,
        max_size=20
    )
)
def test_display_output_preserves_all_scores(sentiments):
    """
    Property 10 (variant): Display output structure for multiple scores
    
    When multiple sentiment scores are generated, each score should contain
    all required fields (score, timestamp, modality contributions).
    
    This variant tests that the data model structure is consistent across
    multiple sentiment scores, which is required for showing trends over time.
    
    Validates:
    - Req 7.1: System displays sentiment score with timestamp
    - Req 7.3: System provides sentiment score history for current session
    """
    # Property assertions: Each sentiment score must have required fields
    
    for i, sentiment in enumerate(sentiments):
        # 1. Must have score
        assert hasattr(sentiment, 'score'), \
            f"Score {i}: must have score attribute"
        assert -1.0 <= sentiment.score <= 1.0, \
            f"Score {i}: score must be in [-1, 1], got {sentiment.score}"
        
        # 2. Must have timestamp
        assert hasattr(sentiment, 'timestamp'), \
            f"Score {i}: must have timestamp attribute"
        assert sentiment.timestamp >= 0, \
            f"Score {i}: timestamp must be non-negative"
        
        # 3. Must have modality_contributions
        assert hasattr(sentiment, 'modality_contributions'), \
            f"Score {i}: must have modality_contributions attribute"
        assert isinstance(sentiment.modality_contributions, dict), \
            f"Score {i}: modality_contributions must be dict"
        assert len(sentiment.modality_contributions) > 0, \
            f"Score {i}: modality_contributions must not be empty"


# Feature: realtime-sentiment-analysis, Property 10: Display output structure
@settings(max_examples=100, deadline=None)
@given(sentiment=sentiment_score_strategy())
def test_display_output_modality_contributions_structure(sentiment):
    """
    Property 10 (variant): Display output modality contributions structure
    
    The modality contributions in a sentiment score must have the correct
    structure: a dictionary with modality names as keys and weights as values.
    
    This variant specifically tests the structure of modality contributions,
    which is critical for Requirement 7.2 (showing individual contributions).
    
    Validates:
    - Req 7.2: System shows individual contributions from acoustic, visual,
               and linguistic analysis
    """
    # Property assertions on modality contributions structure
    
    # 1. Must be a dictionary
    assert isinstance(sentiment.modality_contributions, dict), \
        f"modality_contributions must be dict, got {type(sentiment.modality_contributions)}"
    
    # 2. Must contain at least one modality
    assert len(sentiment.modality_contributions) > 0, \
        "modality_contributions must not be empty"
    
    # 3. All keys must be strings (modality names)
    for key in sentiment.modality_contributions.keys():
        assert isinstance(key, str), \
            f"Modality name must be string, got {type(key)}"
    
    # 4. All values must be numeric weights in [0, 1]
    for modality, weight in sentiment.modality_contributions.items():
        assert isinstance(weight, (int, float)), \
            f"Weight for {modality} must be numeric, got {type(weight)}"
        assert 0.0 <= weight <= 1.0, \
            f"Weight for {modality} must be in [0, 1], got {weight}"
    
    # 5. Weights should sum to approximately 1.0 (allowing for floating point error)
    total_weight = sum(sentiment.modality_contributions.values())
    assert 0.99 <= total_weight <= 1.01, \
        f"Modality weights should sum to ~1.0, got {total_weight}"
    
    # 6. Valid modality names (acoustic, visual, linguistic)
    valid_modalities = {'acoustic', 'visual', 'linguistic'}
    for modality in sentiment.modality_contributions.keys():
        assert modality in valid_modalities, \
            f"Modality name must be one of {valid_modalities}, got '{modality}'"


# Feature: realtime-sentiment-analysis, Property 10: Display output structure
@settings(max_examples=100, deadline=None)
@given(
    score=st.floats(min_value=-1.0, max_value=1.0),
    confidence=st.floats(min_value=0.0, max_value=1.0),
    timestamp=st.floats(min_value=0.0, max_value=10000.0)
)
def test_display_output_with_all_modalities(score, confidence, timestamp):
    """
    Property 10 (variant): Display output with all three modalities
    
    When all three modalities (acoustic, visual, linguistic) contribute to
    a sentiment score, the SentimentScore must contain all three contributions
    in the modality_contributions field.
    
    This variant tests the complete case where all modalities are present,
    which is the ideal operating condition for the system.
    
    Validates:
    - Req 7.2: System shows individual contributions from acoustic, visual,
               and linguistic analysis
    """
    # Create sentiment score with all three modalities
    sentiment = SentimentScore(
        score=score,
        confidence=confidence,
        modality_contributions={
            'acoustic': 0.33,
            'visual': 0.33,
            'linguistic': 0.34
        },
        emotion_breakdown={'happy': 0.5, 'neutral': 0.5},
        timestamp=timestamp
    )
    
    # Property assertions
    
    # 1. All three modalities must be present
    assert 'acoustic' in sentiment.modality_contributions, \
        "Acoustic modality must be present"
    assert 'visual' in sentiment.modality_contributions, \
        "Visual modality must be present"
    assert 'linguistic' in sentiment.modality_contributions, \
        "Linguistic modality must be present"
    
    # 2. Each modality must have a valid weight
    for modality in ['acoustic', 'visual', 'linguistic']:
        weight = sentiment.modality_contributions[modality]
        assert 0.0 <= weight <= 1.0, \
            f"{modality} weight must be in [0, 1], got {weight}"
    
    # 3. Score must be in valid range
    assert -1.0 <= sentiment.score <= 1.0, \
        f"Score must be in [-1, 1], got {sentiment.score}"
    
    # 4. Timestamp must be valid
    assert sentiment.timestamp >= 0, \
        f"Timestamp must be non-negative, got {sentiment.timestamp}"
    
    # 5. Display can accept the score
    display = SentimentDisplay()
    try:
        display.update_score(sentiment)
    except Exception as e:
        assert False, f"Display must accept valid SentimentScore, got: {e}"


# Feature: realtime-sentiment-analysis, Property 10: Display output structure
@settings(max_examples=100, deadline=None)
@given(
    score=st.floats(min_value=-1.0, max_value=1.0),
    confidence=st.floats(min_value=0.0, max_value=1.0),
    timestamp=st.floats(min_value=0.0, max_value=10000.0),
    modality=st.sampled_from(['acoustic', 'visual', 'linguistic'])
)
def test_display_output_with_single_modality(score, confidence, timestamp, modality):
    """
    Property 10 (variant): Display output with single modality
    
    When only one modality contributes to a sentiment score, the SentimentScore
    must still contain all required fields including the single modality
    contribution.
    
    This variant tests the edge case where only one modality is available,
    which can occur when other modalities fail or produce low-confidence results.
    
    Validates:
    - Req 7.1: System displays sentiment score with timestamp
    - Req 7.2: System shows individual contributions from analysis modules
    """
    # Create sentiment score with single modality
    sentiment = SentimentScore(
        score=score,
        confidence=confidence,
        modality_contributions={modality: 1.0},
        emotion_breakdown={'neutral': 1.0},
        timestamp=timestamp
    )
    
    # Property assertions
    
    # 1. Exactly one modality must be present
    assert len(sentiment.modality_contributions) == 1, \
        f"Expected 1 modality, got {len(sentiment.modality_contributions)}"
    
    # 2. The specified modality must be present with weight 1.0
    assert modality in sentiment.modality_contributions, \
        f"{modality} must be present in contributions"
    assert sentiment.modality_contributions[modality] == 1.0, \
        f"{modality} weight must be 1.0, got {sentiment.modality_contributions[modality]}"
    
    # 3. Score must be in valid range
    assert -1.0 <= sentiment.score <= 1.0, \
        f"Score must be in [-1, 1], got {sentiment.score}"
    
    # 4. Timestamp must be valid
    assert sentiment.timestamp >= 0, \
        f"Timestamp must be non-negative, got {sentiment.timestamp}"
    
    # 5. Display can accept the score
    display = SentimentDisplay()
    try:
        display.update_score(sentiment)
    except Exception as e:
        assert False, f"Display must accept valid SentimentScore, got: {e}"


# Feature: realtime-sentiment-analysis, Property 10: Display output structure
@settings(max_examples=100, deadline=None)
@given(sentiment=sentiment_score_strategy())
def test_display_output_emotion_breakdown_structure(sentiment):
    """
    Property 10 (variant): Display output emotion breakdown structure
    
    The emotion breakdown in a sentiment score must have the correct structure:
    a dictionary with emotion names as keys and probability scores as values.
    
    While not explicitly part of Property 10, emotion breakdown is part of
    the display output structure and supports the overall sentiment visualization.
    
    Validates:
    - Req 7.1: System displays sentiment score with timestamp
    """
    # Property assertions on emotion breakdown structure
    
    # 1. Must be a dictionary
    assert isinstance(sentiment.emotion_breakdown, dict), \
        f"emotion_breakdown must be dict, got {type(sentiment.emotion_breakdown)}"
    
    # 2. Must contain at least one emotion
    assert len(sentiment.emotion_breakdown) > 0, \
        "emotion_breakdown must not be empty"
    
    # 3. All keys must be strings (emotion names)
    for key in sentiment.emotion_breakdown.keys():
        assert isinstance(key, str), \
            f"Emotion name must be string, got {type(key)}"
    
    # 4. All values must be numeric probabilities in [0, 1]
    for emotion, prob in sentiment.emotion_breakdown.items():
        assert isinstance(prob, (int, float)), \
            f"Probability for {emotion} must be numeric, got {type(prob)}"
        assert 0.0 <= prob <= 1.0, \
            f"Probability for {emotion} must be in [0, 1], got {prob}"
    
    # 5. Probabilities should sum to approximately 1.0 (allowing for floating point error)
    total_prob = sum(sentiment.emotion_breakdown.values())
    assert 0.99 <= total_prob <= 1.01, \
        f"Emotion probabilities should sum to ~1.0, got {total_prob}"
